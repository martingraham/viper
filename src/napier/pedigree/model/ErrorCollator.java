package napier.pedigree.model;

import java.beans.PropertyChangeSupport;
import java.util.Set;

import napier.pedigree.io.PropertyConstants;
import napier.pedigree.model.filter.MarkerFilter;

import org.resspecies.inheritance.model.HeritablePopulation;
import org.resspecies.inheritance.model.SNPMarker;
import org.resspecies.model.Individual;


import util.Messages;

/**
 * API for collating error details generated by a HeritablePopulation object
 * Built because we didn't have any other way of getting separate counts of errors to mother / father / novel alleles
 * without looping through the entire HeritablePopulation object every time we wanted that info.
 * It then grew a bit as we have three different states of error details:
 * Initial - errors on the first run
 * Current - errors on the last run, with all the masked markers/individuals/genotypes etc
 * Filtered - further set of markers removed from consideration, this is now just used for single marker mode error gathering
 * @author cs22
 *
 */
public interface ErrorCollator {

	public final static int ANY_ERROR = 0;
	public final static int BAD_DAM = 1, BAD_SIRE = 2, NOVEL_ALLELES = 3, INCOMPLETE = 4, MASKED_GENO = 5, MASKED_SIRE = 6, MASKED_DAM = 7;
	public final static int ERROR_RANGE = 6;
	
	public final static String[] ERROR_NAMES = Messages.getString (PropertyConstants.TEXTPROPS, "ErrorNames").split("\\|");
	
	
	// Outgoing property event names
	public final static String RECALC_NEEDED = "recalculationNeeded";
	public final static String RESTRUC_NEEDED = "restructureNeeded";
	public final static String RECALCULATED = "recalculated";
	public final static String RESTRUCTURED = "restructured";
	public final static String FILTER = "filter";
	public final static String REPAINT_NEEDED = "repaintNeeded";
	public final static String STORE_HISTORY = "storeHistoryState";
	
	
	/**
	 * Populate this model with a HeritablePopulation object
	 */
	public void setModel (final HeritablePopulation hpop);
	
	
	
	/**
	 * Recalculates the error matrices, after the HeritablePopulation objects runs an inheritance check
	 */
	public void recalculate ();
	
	
	/**
	 * Flags that changes have been made to the HeritablePopulation model and a recalculation will be necessary to see the effects
	 * @param isNeeded - true if recalc needed, false if resetting this state
	 * @param maskingFlag - flag to state what object has been affected and causes the need for a recalc (marker, ind or genotype)
	 */
	public void setRecalculationNeeded (final boolean isNeeded, final int maskingFlag);
	
	/**
	 * Flags that changes have been made to the HeritablePopulation model and a recalculation will be necessary to see the effects
	 * @param isNeeded - true if recalc needed, false if resetting this state
	 * @param maskingFlag - flag to state what object has been affected and causes the need for a recalc (marker, ind or genotype)
	 * @param affectedMarkers - if markers are causing need for recalc keep track of them because maybe we won't need to recalc 
	 * everything (not possible with inds or genotype changes)
	 */
	public void setRecalculationNeeded (final boolean isNeeded, final int maskingFlag, final Set<SNPMarker> affectedMarkers);
	
	/**
	 * Flags that changes have been made to the HeritablePopulation model that affect the pedigree structure (nulling sire/dam relationships)
	 */
	public void setRestructureNeeded (final boolean isNeeded);
	
	/**
	 * Get number of initial errors associated with an Individual for a given error type
	 * @param errorMapIndex - error type index
	 * @param ind - Individual
	 * @return error count of bad Markers for Individual
	 */
	public int getInitialIndividualErrorCount (int errorMapIndex, final Individual ind);
	
	/**
	 * Get number of errors associated with an Individual for a given error type given current Marker maskings
	 * @param errorMapIndex - error type index
	 * @param ind - Individual
	 * @return error count of bad Markers for Individual
	 */
	public int getCurrentIndividualErrorCount (int errorMapIndex, final Individual ind);
	
	/**
	 * Get number of errors associated with an Individual for a given error type given current Marker maskings
	 * with a further filtering of Markers on top - at the moment these "further markers" is just the marker in the single marker view mode
	 * @param errorMapIndex - error type index
	 * @param ind - Individual
	 * @return error count of bad Markers for Individual
	 */
	public int getFilteredIndividualErrorCount (int errorMapIndex, final Individual ind);
	
	
	/**
	 * Get number of initial errors associated with a SNPMarker for a given error type
	 * @param errorMapIndex - error type index
	 * @param marker - SNPMarker
	 * @return error count of bad Individuals for SNPMarker
	 */
	public int getInitialMarkerErrorCount (int errorMapIndex, final SNPMarker marker);
	
	/**
	 * Get number of errors associated with a SNPMarker for a given error type given current Marker maskings
	 * @param errorMapIndex - error type index
	 * @param marker - SNPMarker
	 * @return error count of bad Individuals for SNPMarker
	 */
	public int getCurrentMarkerErrorCount (int errorMapIndex, final SNPMarker marker);
	
	
	/**
	 * Initial number of Markers passed into model
	 * @return int - initial marker count
	 */
	public int getInitialMarkerSize ();
	
	/**
	 * Initial number of Individuals passed into model
	 * @return int - initial individual count
	 */
	public int getInitialIndividualsSize ();
	
	
	/**
	 * Number of markers remaining after filtering
	 * At the moment, this is either all the unmasked markers or 1 (single marker view)
	 * @return int - filtered marker count
	 */
	public int getFilteredMarkerSize ();

	
	/**
	 * Get an ErrorMatrix of initial errors for a given error type
	 * @return ErrorMatrix - model of initial errors for error type
	 */
	public ErrorMatrix getInitialErrorMap (int errorMapIndex);
	
	/**
	 * Get an ErrorMatrix of errors for a given error type given current Marker maskings
	 * @return ErrorMatrix - model of errors for a given error type given current Marker maskings
	 */
	public ErrorMatrix getCurrentErrorMap (int errorMapIndex);
	
	/**
	 * Get an ErrorMatrix for all occurrences of initial Individual/SNPMarker errors
	 * Shortcut for getInitialErrorMap (ANY_ERROR);
	 * @return ErrorMatrix - model of initial errors for "all errors"
	 */
	public ErrorMatrix getInitialAllErrorMap ();
	
	
	/**
	 * Get an ErrorMatrix for all occurrences of Individual/SNPMarker errors given current Marker maskings
	 * Shortcut for getCurrentErrorMap (ANY_ERROR);
	 * @return ErrorMatrix - model of filtered errors for "all errors"
	 */
	public ErrorMatrix getCurrentAllErrorMap ();
	
	
	/**
	 * Return the sum of errors for all individuals within the current ANY_ERROR map
	 * @return int - value
	 */
	public int getCurrentAllErrorTotal ();
	
	
	/**
	 * Sets a MarkerFilter object, which decides whether Markers are filtered in/out from error
	 * counts upon the next call of filter()
	 * Again, at the mo, the filter either lets everything offered pass or restricts to one marker (single marker view)
	 * @param mFilter - MarkerFilter object
	 */
	public void setFilter (final MarkerFilter mFilter);
	
	/**
	 * Do filtering according to current MarkerFilter
	 */
	public void filter ();
	
	
	/**
	 * @param marker
	 * @return boolean showing whether marker is included by the current MarkerFilter
	 */
	public boolean isFilteredMarker (final SNPMarker marker);
	

	
	/**
	 * returns a PopCheckerWrapper object, whose job is to wrap round a
	 * HeritablePopulation object and offers some utility methods
	 * @return PopCheckWrapper object
	 */
	public PopCheckerWrapper getPopCheckerContext ();
	
	
	/**
	 * Returns an object that handles PropertyEvent code for this class
	 * @return PropertyChangeSupport object
	 */
	public PropertyChangeSupport getPropertyChangeSupport ();
}
